<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.
    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About1" xml:space="preserve">
    <value>本应用通过调用操作系统的标准文件 API（Windows 上的 WinAPI、Mac 上的 POSIX、Android 上的 NDK）来测试存储设备（机械硬盘、固态硬盘、USB 闪存驱动器）和内存（RAM）之间的数据传输速度（单位为 MB/s）。 API 调用通过 .NET Framework 与 Mono 完成。</value>
  </data>
  <data name="About2" xml:space="preserve">
    <value>顺序读取与顺序写入测试通过在储存设备和 RAM 之间传输大块数据（MB 级别）来测试复制大文件、视频录制、编码、解码等日常应用环境中的储存性能。</value>
  </data>
  <data name="About3" xml:space="preserve">
    <value>随机读取与随机写入通过读写测试文件中的随机位置的小块数据（4KB 和 32KB）来测试文件系统性能对应用加载、小文件复制、数据库查询能力的影响。此测试的运行时间为 7 秒。</value>
  </data>
  <data name="About4" xml:space="preserve">
    <value>在“选项”中，以下设置会对测试结果产生影响：</value>
  </data>
  <data name="About5" xml:space="preserve">
    <value>• 写入缓存 — 影响写入测试。通过在写入操作中使用中间缓冲区，将写入数据进行排序，以在最佳的写入时机写入数据来提升数据写入能力。其代价是较低的弹性写入能力（例如发生电源故障导致缓冲区内的数据丢失，或是写入那些无法使用缓冲区的数据）。</value>
  </data>
  <data name="About6" xml:space="preserve">
    <value>• 内存缓存 — 影响读取测试。在内存充足的情况下，任何向操作系统发出的文件操作请求，不论是将储存中的数据读入内存，还是将内存中的数据写入储存，操作系统都会将那些内存页保留在内存中待用。后续如果操作系统通过 API 收到的文件读取/写入请求，操作系统将会直接调用之前保留在内存中的内存页，而不是实际的储存设备。启用此选项时，测试结果所反映的是操作系统的内存缓存性能以及内存本身的性能，而非储存设备的性能。</value>
  </data>
  <data name="About7" xml:space="preserve">
    <value>无论是家用计算机还是智能手机，处理器（CPU）的操作都依赖于加载在系统内存（RAM）中的数据。因为内存具有易失性且容量有限，这也是为什么我们需要外部储存设备（固态硬盘、机械硬盘、SD 卡等，它们也被称作“磁盘”或“驱动器”）。在很多情况下，系统的整体性能不光取决于 CPU（虽然 CPU 的权重的确很高，而且往往是产品营销和跑分软件中的头牌），还取决于储存——具体来说是内部储存（RAM）和外部储存。官方参数（特别是智能手机）往往对储存方面的性能语焉不详。本程序致力于通过独立且合理的3个维度，即：读取速度（从储存设备到内存）、写入速度（从内存到储存设备）、内存复制（从内存的一个区域到另一个区域）来全面评价系统的储存性能。</value>
  </data>
  <data name="About8" xml:space="preserve">
    <value>本程序是开源的，您可以通过以下链接查看项目的 GitHub：</value>
  </data>
  <data name="AndroidSameAliases" xml:space="preserve">
    <value>这俩驱动器是一样的，只是名称/路径不同而已</value>
  </data>
  <data name="AvailableDrives" xml:space="preserve">
    <value>可用的驱动器：</value>
  </data>
  <data name="b" xml:space="preserve">
    <value>B</value>
  </data>
  <data name="Block" xml:space="preserve">
    <value>块</value>
  </data>
  <data name="bps" xml:space="preserve">
    <value>B/s</value>
  </data>
  <data name="BreakTest" xml:space="preserve">
    <value>[Esc, B]中断</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>[Esc, C]关闭</value>
  </data>
  <data name="CsvOption" xml:space="preserve">
    <value>[E]将结果导出到CSV表格中</value>
  </data>
  <data name="FileSizeOption" xml:space="preserve">
    <value>[F]测试文件大小</value>
  </data>
  <data name="gb" xml:space="preserve">
    <value>GB</value>
  </data>
  <data name="GbFree" xml:space="preserve">
    <value>GB 可用</value>
  </data>
  <data name="gbps" xml:space="preserve">
    <value>GB/s</value>
  </data>
  <data name="HelpButton" xml:space="preserve">
    <value>[?, H]帮助</value>
  </data>
  <data name="HintAndroid" xml:space="preserve">
    <value>请单击选择驱动器以开始测试</value>
  </data>
  <data name="HintMisc" xml:space="preserve">
    <value>请单击选择驱动器或按下列表中的数字键以开始测试</value>
  </data>
  <data name="kb" xml:space="preserve">
    <value>KB</value>
  </data>
  <data name="kbps" xml:space="preserve">
    <value>KB/s</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>[L]语言:</value>
  </data>
  <data name="Max" xml:space="preserve">
    <value>最高</value>
  </data>
  <data name="mb" xml:space="preserve">
    <value>MB</value>
  </data>
  <data name="mbps" xml:space="preserve">
    <value>MB/s</value>
  </data>
  <data name="MemCacheOption" xml:space="preserve">
    <value>[M]内存缓存</value>
  </data>
  <data name="MemCopyTest" xml:space="preserve">
    <value>内存复制</value>
  </data>
  <data name="MemCopyTestShort" xml:space="preserve">
    <value>内存
复制</value>
  </data>
  <data name="MemCopyTestShortNB" xml:space="preserve">
    <value>内存复制</value>
  </data>
  <data name="Compare" xml:space="preserve">
    <value>⇆ 比较</value>
  </data>
  <data name="Share" xml:space="preserve">
    <value>⬑分享⬏</value>
  </data>
  <data name="ShareTitle" xml:space="preserve">
    <value>欢迎下载安卓版跨平台硬盘测试：https://play.google.com/store/apps/details?id=com.Saplin.CPDT</value>
  </data>
  <data name="Min" xml:space="preserve">
    <value>最低</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>(关)</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>(开)</value>
  </data>
  <data name="OptionsButton" xml:space="preserve">
    <value>[O]选项</value>
  </data>
  <data name="PickDrive" xml:space="preserve">
    <value>- 选择一个驱动器并对其进行性能测试</value>
  </data>
  <data name="ProjectLink" xml:space="preserve">
    <value>https://github.com/maxim-saplin/CrossPlatformDiskTest</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>[Q]退出</value>
  </data>
  <data name="Quiting" xml:space="preserve">
    <value>正在终止此项操作...</value>
  </data>
  <data name="RandomReadTest" xml:space="preserve">
    <value>随机读取</value>
  </data>
  <data name="RandomReadTestShort" xml:space="preserve">
    <value>随机
读取</value>
  </data>
  <data name="RandomReadTestShortNB" xml:space="preserve">
    <value>随机读取</value>
  </data>
  <data name="RandomWriteTest" xml:space="preserve">
    <value>随机写入</value>
  </data>
  <data name="RandomWriteTestShort" xml:space="preserve">
    <value>随机
写入</value>
  </data>
  <data name="RandomWriteTestShortNB" xml:space="preserve">
    <value>随机写入</value>
  </data>
  <data name="RefreshButton" xml:space="preserve">
    <value>[R]刷新</value>
  </data>
  <data name="SequentialReadTest" xml:space="preserve">
    <value>顺序读取</value>
  </data>
  <data name="SequentialReadTestShort" xml:space="preserve">
    <value>顺序
读取</value>
  </data>
  <data name="SequentialReadTestShortNB" xml:space="preserve">
    <value>顺序读取</value>
  </data>
  <data name="SequentialWriteTest" xml:space="preserve">
    <value>顺序写入</value>
  </data>
  <data name="SequentialWriteTestShort" xml:space="preserve">
    <value>顺序
写入</value>
  </data>
  <data name="SequentialWriteTestShortNB" xml:space="preserve">
    <value>顺序写入</value>
  </data>
  <data name="StatusBreakingTest" xml:space="preserve">
    <value>突破测试</value>
  </data>
  <data name="StatusTestCompleted" xml:space="preserve">
    <value>测试成功完成，测试文件已删除。</value>
  </data>
  <data name="StatusTestCsvCompleted" xml:space="preserve">
    <value>测试成功完成，已将测试结果导出到CSV表格。</value>
  </data>
  <data name="StatusTestError" xml:space="preserve">
    <value>测试过程由于错误而中断</value>
  </data>
  <data name="StatusTestInterrupted" xml:space="preserve">
    <value>测试过程被中断。测试文件已删除</value>
  </data>
  <data name="TestInitMemBuffer" xml:space="preserve">
    <value>正在初始化内存中的测试数据...</value>
  </data>
  <data name="TestNotEnoughMemory" xml:space="preserve">
    <value>内存不足</value>
  </data>
  <data name="TestPurgingMemCache" xml:space="preserve">
    <value>正在清除内存缓存...</value>
  </data>
  <data name="TestRunning" xml:space="preserve">
    <value>正在运行测试...</value>
  </data>
  <data name="TestStarted" xml:space="preserve">
    <value>测试开始</value>
  </data>
  <data name="TestSummaryFormatString" xml:space="preserve">
    <value>文件大小：{0}GB、可用空间：{1:0.0}GB、写入缓存：{2}、内存缓存：{3}</value>
  </data>
  <data name="TestSummaryShortFormatString" xml:space="preserve">
    <value>大小：{0}GB、空间：{1:0.0}GB、写入缓存：{2}、缓存：{3}</value>
  </data>
  <data name="TestWarmigUp" xml:space="preserve">
    <value>测试准备中...</value>
  </data>
  <data name="WhiteTheme" xml:space="preserve">
    <value>[W]白色主题（重启程序生效）</value>
  </data>
  <data name="WriteBufferingOption" xml:space="preserve">
    <value>[B]写入缓存：</value>
  </data>
  <data name="CClose" xml:space="preserve">
    <value>关闭</value>
  </data>
  <data name="Database" xml:space="preserve">
    <value>[D]排行榜</value>
  </data>
  <data name="DbNotAvailable" xml:space="preserve">
    <value>测试成绩排行榜不可用，请检查互联网连接。</value>
  </data>
  <data name="DownloadLink" xml:space="preserve">
    <value>https://maxim-saplin.github.io/cpdt_results/?download=&amp;lang=zh&amp;app=</value>
  </data>
  <data name="About9" xml:space="preserve">
    <value>您可以通过以下链接下载适用于不同平台（Windows，macOS，Android/APK）的应用程序：</value>
  </data>
  <data name="DownloadLinkShort" xml:space="preserve">
    <value>https://maxim-saplin.github.io/cpdt_results/?download=&amp;lang=zh</value>
  </data>
  <data name="ModeH" xml:space="preserve">
    <value>众数</value>
  </data>
  <data name="About10" xml:space="preserve">
    <value>每次测试的结果都由一个图表来呈现。顺序测试和内存测试采用针对块（储存单位）绘制的实时速度曲线图（刻度为 1 个块），随着测试的进行，您可以清晰的看到整个读写过程的变化。有时您可能会注意到，在某些测试操作下，读写设备会表现出延迟的现象，不必担心这是正常的（Android 设备上较为常见）。随机测试采用基于测试块在整个测试文件中分布位置的直方图，此图清晰的展示了随机读写速度是如何依照测试块位置分布的。为了将直方图显示的更加完整清晰，对于那些取自测试文件头部和尾部的测试数据（我们称之为“尾巴”，通常占比不到总数据的 3％，对速度分布规律几乎没有影响）将直接合并至直方图最左侧和最右侧的单个直方中。如果你在直方图中观察到了带有箭头的竖线，说明尾巴已被最小化（有时也会出现不需要最小化尾巴的情况）。那些夹在箭头和竖线中间的直方包括了 94% 的测试数据（此时最大值和最小值并不包括在其中，而被当作“尾巴”处理，且测试结果所显示最大值与最小值并非测试过程中的真实值）。那些夹在两个箭头中的直方即为“众数” —— 是指一组数据中出现次数最多的那个数据，代表数据的一般水平，一组数据可以有多个众数，也可以没有众数。</value>
  </data>
  <data name="SimpleUI_StartA" xml:space="preserve">
    <value>开始一次</value>
  </data>
  <data name="SimpleUI_Test" xml:space="preserve">
    <value>[T]测试</value>
  </data>
  <data name="SimpleUI_OrSee" xml:space="preserve">
    <value>或查看</value>
  </data>
  <data name="SimpleUI_More" xml:space="preserve">
    <value>[M]更多</value>
  </data>
  <data name="SimpleUIOption" xml:space="preserve">
    <value>[S]简化UI</value>
  </data>
  <data name="CantTestNotEnough" xml:space="preserve">
    <value>无法测试某些驱动器，需要至少 {0}GB 可用空间</value>
  </data>
  <data name="TestOf" xml:space="preserve">
    <value>正测试第 {0} 项，共 {1} 项</value>
  </data>
  <data name="TestTotal" xml:space="preserve">
    <value>已完成 {0:0}％</value>
  </data>
  <data name="InitDrivesError" xml:space="preserve">
    <value>读取可用驱动器/分区时发生错误，测试无法执行。</value>
  </data>
  <data name="NotEnoughSpaceHint" xml:space="preserve">
    <value>空间不足</value>
  </data>
  <data name="NotAccessibleDriveHint" xml:space="preserve">
    <value>不可用</value>
  </data>
</root>
